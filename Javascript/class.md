# 클래스

- 생성자 함수와 마찬가지로 객체를 생성할 수 있는 템플릿 이다.
- 생성자 함수로 생성하는 방법은 더 이상 쓰이지 않는다. (레거시방법)
- es6 이후부터 등장하였고 조금 더 쉽게 객체를 생성할 수 있다

**인스턴스** : 클래스를 이용해서 만들어진 객체

**Constroctor**: new 키워드로 객체를 생성할때 처음 호출되는 함수, 속성을 추가하는 등 객체 초기화 처리 

```
class MyClass {

constructor (인자,인자2) {

this.인자 = 인자;

this.인자2 = 인자2;

}
method() {}
// 주의할점 : 매서드 사이에 , 없다. 
method2 = () ⇒ {} // 클래스에 필요한 함수는 생성자 함수 밖에서 작성 (this 안해도 된다)
// 만들어진 매서드는 인스턴스를 생성할때 인스턴스의 프로토타입에 저장된다. 
}


new MyClass (); -> 클래스 내부에서 정의한 메서드가 들어 있는 객체 생성

```

- 인스턴스레벨의 프로퍼티와 메소드 클래스에서는 접근이 불가능하다. 인스턴스.메소드()

- 클래스 레벨의 프로퍼티와 메소드 (static 정적 프로퍼티, 메소드) : Static 키워드를 프로퍼티나 메소드 앞에 작성하면 만들어진 인스턴스에 포함되지 않으며, 클래스에 남아 있게 된다. 클래스에 한번만 작성하고 재사용할 수 있다. 클래스.메소드(); 

클래스레벨의 메서드 에서는 this를 참조할 수 없다



### 클래스 필드

생성자 밖에서 초기화하고, 선언할 수 있다.

### 접근제어자 
한번 만들어지면 외부에서 변경이 불가능하게 하려면?! 캡슐화 해야한다. 

- public(기본) 
- #(Private) - 외부에서 접근 불가능하다

### 접근자 프로퍼티 

- getter
- setter 

변수처럼 보이지만 실제로는 함수, 속성의 한 부분이라고 생각되는 부분을 호출할때 이렇게 만듬 

get 함수명 () ⇒ {} // 함수명 ⇒ 호출됨

### 클래스 확장(extends) - 상속

클래스마다 공통된 게 있다면, 상속을 이용해서 공통된 속성과 행동을 그대로 받을 수 있다 .

**super()** : 내가 상속하고 있는 부모를 가르킨다.

**오버라이딩** : 자식클래스에서 메소드 덮어쓸때 extends를 이용해서 부모 클래스에서 상속 받고, 이외에 추가 메서드는 속성을 추가하려면

추가 메서드는 그냥 작성해주면 되고,

속성은 constrouctor()를 이용하고, 부모 요소에서 상속받은 속성도 입력이 필요함

class Dog extends Animal {

constrouctor(color,ownerName)

super(color) ←부모 생성자의 속성 정보를 전달 받음 

this.ownerName = ownerName;

}